
// This script stores functionalities of all available app

// import module
var palettes = require('users/gena/packages:palettes');
var helper = require('users/pinkychow1010/WB_IntraUrban:helper');
var analysis = require('users/pinkychow1010/WB_IntraUrban:analysis_utils');
var basemap = require('users/pinkychow1010/WB_IntraUrban:basemap_resources');
var intraUrban = require('users/pinkychow1010/WB_IntraUrban:app_interface');

// app functions

exports.set_up = function set_up() {
  
  // config base map
  basemap.addCustomBasemap('MutedMonotone');
  Map.setCenter(70, 30, 4.5);
  
  // turn off drawing tool bar
  Map.setControlVisibility({drawingToolsControl:false});
};

exports.pop_count = function pop_app() {
  var geometry = ee.FeatureCollection("projects/ee-pinkychow1010/assets/WB_GEE/karachi_union_council_subset");
  analysis.zonal_pop_sum(geometry);
};

exports.fvc_lst_impact = function fvc_lst_impact() {
  intraUrban.app(fvc_lst_impact);
};

function fvc_lst_impact(aoi){
  
  function rollingMean(collection) {
    function doIt(idx) {
      var d1 = date0.advance(ee.Number(idx).add(2), "year");  // last year will be excluded
      var d0 = d1.advance(-3, "year");
      return collection.filterDate(d0, d1)
      .reduce(ee.Reducer.median())
      .set("system:time_start", d0.advance(1, "year"));
    }
    return doIt;
  }
  
  // check location
  var bbox = aoi.geometry();
  var centroid = bbox.centroid({'maxError': 1});
  var listCoords = ee.Array.cat(centroid.coordinates(), 0);
  var yCoords = ee.List(listCoords).getInfo()[1];
  
  // south/ north
  var south = ee.Number(yCoords).lt(0);
  var shift = south.multiply(6).getInfo();
  
  // evaluation year
  var start_year = ee.Date("2000-01-01");
  var end_year = ee.Date("2021-01-01");
  
  // filter dataset to evaluation year
  var yearFilter = ee.Filter.date(
    start_year.advance(-1, "year"), 
    end_year.advance(1, "year")
    );
  
  // get summer months depends on location
  var summerFilter = ee.Filter.calendarRange(5+shift, 9-shift, "month");
  
  // modis land surface temperature (day and night)
  var modisLST = ee.ImageCollection("MODIS/061/MOD11A1")
    .filter(summerFilter).filter(yearFilter) // filter images
    .map(function(img) {
      return img.multiply(0.02).subtract(273.15) // apply scale factor and offset
      .copyProperties(img, ["system:time_start"]);
  });
  
  // extract Landsat time series and merge to single collection
  var ndviLandsat5 = ee.ImageCollection("LANDSAT/LT05/C01/T1_32DAY_NDVI").filter(yearFilter);
  var ndviLandsat7 = ee.ImageCollection("LANDSAT/LE07/C01/T1_32DAY_NDVI").filter(yearFilter);
  var ndviLandsat8 = ee.ImageCollection("LANDSAT/LC08/C01/T1_32DAY_NDVI").filter(yearFilter);
  var ndvi = ndviLandsat5.merge(ndviLandsat7.merge(ndviLandsat8)).filterBounds(aoi);
  
  var fvc = ndvi.map(function(img) {
    var f = ee.Image(
      (img.subtract(0.1))
      .divide(ee.Number(0.5).subtract(ee.Number(0.1)))
      )
      .multiply(100);
    return f.where(f.gt(100), 100).where(f.lt(0), 0).copyProperties(img, ["system:time_start"]);
  });
  
  // check out images with before and after scanerios
  var before = fvc.filter(ee.Filter.date('2001-01-01', '2001-12-01')).median().clip(aoi);
  var after = fvc.filter(ee.Filter.date('2020-01-01', '2020-12-01')).median().clip(aoi);
  

  // ################################################ //
  // ########## VEGETATION LOSS GROUP ############### //
  // ################################################ //
  
   // get urban areas
  var urban_mask = ee.ImageCollection('ESA/WorldCover/v200').first().clip(bbox).eq(50);
  
  // calculate urban density
  var reduceNeighborhood = urban_mask.reduceNeighborhood(
    ee.Reducer.mean(), 
    ee.Kernel.circle(5000, 'meters')
  ).multiply(100).toByte();

  // focus on dense areas
  var urban_threshold = reduceNeighborhood.gt(2);
  
  // Map.addLayer(before, {min: 0, max: 20, palette: ['white', 'green']}, "FVC 2001");
  // Map.addLayer(after, {min: 0, max: 20, palette: ['white', 'green']}, "FVC 2020");
  Map.addLayer(after.subtract(before).updateMask(urban_threshold), {min: -10, max: 10, palette: ['red', 'white', 'green']}, "FVC Difference");
  
  var threshold = (after.subtract(before)).lt(-20).and(urban_threshold);
  
  // FVC at different temporal aggregations (create sequence)
  var date0 = start_year.advance(1, "year");
  var n_years = end_year.difference(date0, "year").toInt().subtract(2);
  var idxs = ee.List.sequence(0, n_years);
  
  // Fractional Vegetation Cover, LST Day Time, LST Night Time
  // create smoothed temperol sequence
  var lstDay = ee.ImageCollection.fromImages(idxs.map(rollingMean(modisLST.select("LST_Day_1km"))));
  var lstNight = ee.ImageCollection.fromImages(idxs.map(rollingMean(modisLST.select("LST_Night_1km"))));
  var fvc_ds = ee.ImageCollection.fromImages(idxs.map(rollingMean(fvc)));
  
  // generate line chart for visualization
  
  // FRACTIONAL VEGETATION CHANGE 
  var fvcStyle = {
    title: 'Fractional Vegetation Cover Time Series (Vegetation Loss)',
            hAxis: {title: 'Year', titleTextStyle: {italic: false, bold: true}},
            vAxis: {
              title: 'FVC',
              titleTextStyle: {italic: false, bold: true}
            },
            lineWidth: 2,
            colors: ['green']
  };
  
  var fvcChart1 = ui.Chart.image.series({
      imageCollection: fvc_ds.map(function (image) {
        return image.updateMask(threshold)
      }),
      region: aoi,
      reducer: ee.Reducer.mean(),
      scale: 500
    }).setOptions(fvcStyle);
  
  // DAY TEMP
  var dayStyle = {
            title: 'MODIS Day LST Time Series (Vegetation Loss)',
            hAxis: {title: 'Year', titleTextStyle: {italic: false, bold: true}},
            vAxis: {
              title: 'Day Time Temp',
              titleTextStyle: {italic: false, bold: true}
            },
            lineWidth: 2,
            colors: ['red']
          };
  
  var dayChart1 = ui.Chart.image.series({
      imageCollection: lstDay.map(function (image) {
        return image.updateMask(threshold)
      }),
      region: aoi,
      reducer: ee.Reducer.median(),
      scale: 500
    }).setOptions(dayStyle);
  
  // NIGHT TEMP
  var nightStyle = {
    title: 'MODIS Night LST Time Series (Vegetation Loss)',
            hAxis: {title: 'Year', titleTextStyle: {italic: false, bold: true}},
            vAxis: {
              title: 'Night Time Temp',
              titleTextStyle: {italic: false, bold: true}
            },
            lineWidth: 2,
            colors: ['blue']
  };
  
  var nightChart1 = ui.Chart.image.series({
      imageCollection: lstNight.map(function (image) {
        return image.updateMask(threshold)
      }),
      region: aoi,
      reducer: ee.Reducer.median(),
      scale: 500
    }).setOptions(nightStyle);
  
  // ################################################ //
  // ########## VEGETATION GAIN GROUP ############### //
  // ################################################ //
  
  var threshold = (after.subtract(before)).gt(20).and(urban_threshold);
  
  // VEGETATION FRACTIONAL COVER
  var fvcStyle = {
    title: 'Fractional Vegetation Cover Time Series (Vegetation Gain)',
            hAxis: {title: 'Year', titleTextStyle: {italic: false, bold: true}},
            vAxis: {
              title: 'FVC',
              titleTextStyle: {italic: false, bold: true}
            },
            lineWidth: 2,
            colors: ['green']
  };
  
  var fvcChart2 = ui.Chart.image.series({
      imageCollection: fvc_ds.map(function (image) {
        return image.updateMask(threshold)
      }),
      region: aoi,
      reducer: ee.Reducer.mean(),
      scale: 500
    }).setOptions(fvcStyle);
  
  // DAY TEMP
  var dayStyle = {
            title: 'MODIS Day LST Time Series (Vegetation Gain)',
            hAxis: {title: 'Year', titleTextStyle: {italic: false, bold: true}},
            vAxis: {
              title: 'Day Time Temp',
              titleTextStyle: {italic: false, bold: true}
            },
            lineWidth: 2,
            colors: ['red']
          };
  
  var dayChart2 = ui.Chart.image.series({
      imageCollection: lstDay.map(function (image) {
        return image.updateMask(threshold)
      }),
      region: aoi,
      reducer: ee.Reducer.median(),
      scale: 500
    }).setOptions(dayStyle);
  
  // NIGHT TEMP
  var nightStyle = {
    title: 'MODIS Night LST Time Series (Vegetation Gain)',
            hAxis: {title: 'Year', titleTextStyle: {italic: false, bold: true}},
            vAxis: {
              title: 'Night Time Temp',
              titleTextStyle: {italic: false, bold: true}
            },
            lineWidth: 2,
            colors: ['blue']
  };
  
  var nightChart2 = ui.Chart.image.series({
      imageCollection: lstNight.map(function (image) {
        return image.updateMask(threshold)
      }),
      region: aoi,
      reducer: ee.Reducer.median(),
      scale: 500
    }).setOptions(nightStyle);
    
  return [
    fvcChart1, dayChart1, nightChart1,
    fvcChart2, dayChart2, nightChart2,
    ];
};





function aoi_analysis_app(action_call, title_name) {
  
  // define app name
  if (title_name === undefined || title_name === null){var title_name = "World Bank Intra-Urban Analysis Tool"}
  
  // Import geometry boundary data for user selection
  var ADM0 = ee.FeatureCollection("projects/sat-io/open-datasets/geoboundaries/CGAZ_ADM0");
  var ADM1 = ee.FeatureCollection("projects/sat-io/open-datasets/geoboundaries/CGAZ_ADM1");
  var ADM2 = ee.FeatureCollection("projects/sat-io/open-datasets/geoboundaries/CGAZ_ADM2");
  
  // ################################# //
  // ########### GUI APP ############# //
  // ################################# //
  
  var mainPanel = ui.Panel();
  
  mainPanel.style().set({
    width: '240px',
    backgroundColor: 'white'
  });
  
  ui.root.insert(0,mainPanel);
  
  var title = ui.Label(title_name);
  
  title.style().set({
    'position':  'top-center',
    'fontSize': '24px',
    'color': '#002244',
    'fontWeight': 'bold',
    'fontFamily': 'monospace'
    });
    
  mainPanel.add(title);
  
  // Create a panel to hold the drop-down boxes
  var dropdownPanel = ui.Panel();
  
  // Create a panel to hold the result
  var resultPanel = ui.Panel();
  
  // Define 3 dropdowns for admin0, admin1 and admin2 names
  
  // Keep them disbled. We will add items later
  var admin0Select = ui.Select({
      placeholder: 'please wait..',
    }).setDisabled(true)
    
  var admin1Select = ui.Select({
      placeholder: 'select a country first',
    }).setDisabled(true)
    
  var admin2Select = ui.Select({
    placeholder: 'select admin 1 unit first',
  }).setDisabled(true)
  
  dropdownPanel.add(admin0Select)
  dropdownPanel.add(admin1Select)
  dropdownPanel.add(admin2Select)
  
  mainPanel.add(dropdownPanel)
  mainPanel.add(resultPanel)
  
  // Define the onChange() function for admin0Select
  var admin0Selected = function(admin0Selection) {
    
    resultPanel.clear()
    Map.clear()
    
    admin1Select.items().reset()
    admin2Select.items().reset()
    admin1Select.setPlaceholder('please wait..')
    admin2Select.setPlaceholder('Select a admin 1 unit first..')
  
    // Now we have admin0 values, fetch admin1 values for that country
    
    var selectedAdmin0 = ADM0.filter(ee.Filter.eq('shapeName', admin0Selection));
    var shapeID = ee.Feature(selectedAdmin0.first()).get('shapeID');
    var selectedAdmin1 = ADM1.filter(ee.Filter.eq('ADM0_shape', shapeID));
  
    var admin1Names = selectedAdmin1
      .aggregate_array('shapeName')
      .sort()
  
    // Use evaluate() to not block the UI
    admin1Names.evaluate(function(items){
      admin1Select.setPlaceholder('select admin1 unit')
      admin1Select.items().reset(items)
      // Now that we have items, enable the menu
      admin1Select.setDisabled(false)
    })
  }
  
  // Define the onChange() function for admin1Select
  var admin1Selected = function(admin1Selection) {
    resultPanel.clear()
    Map.clear()
    admin2Select.setPlaceholder('please wait..')
  
    var selectedAdmin1 = ADM1.filter(ee.Filter.eq('shapeName', admin1Selection));
    
    var shapeID = ee.Feature(selectedAdmin1.first()).get('shapeID');
    var selectedAdmin2 = ADM2.filter(ee.Filter.eq('ADM1_shape', shapeID));
  
    var admin2Names = selectedAdmin2
      .aggregate_array('shapeName')
      .sort()
  
    
    admin2Names.evaluate(function(items){
      if (items.length == 0) {
        items = ['No Admin2 Units']
        admin2Select.items().reset(items)
      }
      else {
        admin2Select.items().reset(items)  
      }
      admin2Select.setPlaceholder('select admin2 unit')
      admin2Select.setDisabled(false)
    })
  }
  
  // Define the onChange() function for admin2Select
  var admin2Selected = function(admin1Selection) {
    
    resultPanel.clear()
    Map.clear()
    
    var admin0Value = admin0Select.getValue()
    var admin1Value = admin1Select.getValue()
    var admin2Value = admin2Select.getValue()
    
    var selectedAdmin1 = ADM1.filter(ee.Filter.eq('shapeName', admin1Value));
    var shapeGroup = ee.Feature(selectedAdmin1.first()).get('shapeGroup');
    
    // Some regions do not have admin2 values
    // We are on client-side, so using if/else is ok
    if (admin2Value == 'No Admin2 Units') {
        var result = admin1Value + ',' + admin0Value
        var filtered = ADM1
          .filter(ee.Filter.eq('shapeName', admin1Value))
          .filter(ee.Filter.eq('shapeGroup', shapeGroup))
    }
    else {
        var result = admin2Value + ',' + admin1Value + ',' + admin0Value
        var filtered = ADM2
          .filter(ee.Filter.eq('shapeName', admin2Value))
          .filter(ee.Filter.eq('shapeGroup', shapeGroup))
          .filter(ee.Filter.intersects('.geo', selectedAdmin1.geometry()));
  
    }
    var label = ui.Label('You selected: ' + result)
    resultPanel.add
    
    // Action 
    Map.centerObject(filtered)
    var output = action_call(filtered);
    
    var n = 0;
    if (typeof(output) !== 'undefined') {
      if (output.length > 1) {
        while (n < output.length) {
          resultPanel.add(output[n]);
          n++;
        }
      } else {
        resultPanel.add(output);
      }
    }
  
  // Register the callback functions
  admin0Select.onChange(admin0Selected)
  admin1Select.onChange(admin1Selected)
  admin2Select.onChange(admin2Selected)
  
  // Get all country names and sort them
  var admin0Names = ADM0.aggregate_array('shapeName').sort().distinct()
  // Fetch the value using evaluate() to not block the UI
  admin0Names.evaluate(function(items){
    admin0Select.items().reset(items)
    // Now that we have items, enable the menu
    admin0Select.setDisabled(false)
    // Change placeholder
    admin0Select.setPlaceholder('Select a country for analysis')
  })

}}







